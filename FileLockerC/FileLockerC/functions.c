#include "functions.h"

int inc = 0;

/*******************
/*  DATABASE
*******************/
int RunDB()
{
    struct User**   m_Users = (struct User**)malloc(sizeof(struct User*) * MAX_USERS);
    int*            m_NumberOfUsers = (int*)malloc(sizeof(int));
    *m_NumberOfUsers = 0;
    inc = 1;

    AddUser(m_Users, m_NumberOfUsers, "1", "2");
    AddUser(m_Users, m_NumberOfUsers, "Name_2", "Pass_2");
    AddUser(m_Users, m_NumberOfUsers, "Name_3", "Pass_3");

    // Active user 
    struct User** m_UserActive = (struct User**)malloc(sizeof(struct User*));
    *m_UserActive = NULL;

    int done = 1;
    while (done == 1)
    {
        // Logged in
        if (*m_UserActive != NULL)
            iRunLocker(m_UserActive, &done);

        // NOT logged in
        else
            done = StartMenuPanel(m_UserActive, m_Users, m_NumberOfUsers);
    }

    int counter = *m_NumberOfUsers;
    struct User** original = m_Users;
    while (counter > 0)
    {
        struct User* user = *m_Users;

        // Remove each user's savefiles
        int saveFileCounter = user->s_SaveData.s_NumberOfSavedFiles;
        struct SaveFile** savefiles = user->s_SaveData.s_Saved;
        while (saveFileCounter > 0)
        {
            free(*savefiles);
            saveFileCounter--;
            savefiles++;
        }
        free(user->s_SaveData.s_Saved);

        // Remove user
        free(user);
        counter--;
        m_Users++;
    }

    free(original);
    free(m_UserActive);
    free(m_NumberOfUsers);

    printf("\nBye!\n");

    return 0;
}

int StartMenuPanel(struct User** userActive, struct User** users, int* count)
{
    int quit = 1;
    int selection = -1;

    printf("\n1. Login\n2. Create User.\n3. Quit\n(DEBUG)4. Print all users in database.\n Input: ");
    scanf("%d", &selection);

    switch (selection)
    {
    case 1: StartMenuLogin(userActive, users, count);   break;
    case 2: StartMenuCreate(users, count);              break;
    case 3: quit = 0;                                   break;
    case 4: PrintAllUsers(users, count);                break;
    default: break;
    }

    return quit;
}

void StartMenuLogin(struct User** m_UserActive, struct User** users, int* count)
{
    char name[MAX_CHAR_NAME];
    char pass[MAX_CHAR_PASS];

    printf("\n\n\nLogin!\n");
    printf("*******\n");
    printf("Username: ");
    scanf("%23s", name);
    printf("*******\n");
    printf("Password: ");
    scanf("%23s", pass);

    struct User* user = CheckCredentials(users, count, name, pass);
    if (user != NULL)
    {
        printf("Sucess!");
        *m_UserActive = user;
    }
}

void StartMenuCreate(struct User** users, int* count)
{
    char name[MAX_CHAR_NAME];
    char pass[MAX_CHAR_PASS];

    printf("\n\n\nCreate an account!\n");
    printf("*******\n");
    printf("Username: ");
    scanf("%23s", name);
    printf("*******\n");
    printf("Password: ");
    scanf("%23s", pass);

    AddUser(users, count, name, pass);
}

struct User* CheckCredentials(struct User** users, int* count, char* name, char* pass)
{
    struct User* success = NULL;
    struct User** original = users;
    int counter = *count;
    while (counter > 0 && !success)
    {
        if (strcmp(name, (*users)->s_Username) == 0 && 
            strcmp(pass, (*users)->s_Password) == 0)
                success = *users;

        counter--;
        users++;
    }
    users = original;

    if (!success)
        printf("\nWrong password/username.\n Good luck next time.\n");

    return success;
}

void AddUser(struct User** users, int* count, char* name, char* pass)
{
    if (inc * MAX_USERS <= count)
    {
        inc++;
        
        // Allocates the new size of a array with an increased size of MAX_USERS
        struct User** temp = (struct User**)malloc(sizeof(struct User*) * MAX_USERS * inc);
        
        // Removes the previous user array and at the same time copies over the data to the new array
        int counter = *count;
        struct User** old = users;
        struct User** new = temp;
        while (counter > 0)
        {
            struct User* user = *old;

            // Copies the content from the old array spot to the new array
            *new = (struct User*)malloc(sizeof(struct User));    
            DefaultUser(new);
            
            // Setting inserted name and password to the fresh array
            memcpy((*new)->s_Username, user->s_Name, MAX_CHAR_NAME);
            memcpy((*new)->s_Password, user->s_PAss, MAX_CHAR_PASS);
            new->s_SaveData.s_NumberOfSavedFiles = user->s_SaveData.s_NumberOfSavedFiles;
            
            // Remove each user's savefiles
            int saveFileCounter = user->s_SaveData.s_NumberOfSavedFiles;
            struct SaveFile** savefiles = user->s_SaveData.s_Saved;
            struct SaveFile** newSaves = new->s_SaveData.s_Saved;
            while (saveFileCounter > 0)
            {
                *newSaves = *savefiles;
                free(*savefiles);
                saveFileCounter--;
                savefiles++;
                newSaves++;
            }
            free(user->s_SaveData.s_Saved);

            // Remove user
            free(user);
            counter--;
            old++;
            new++;
        }
        
        free(old);
      
        // Point to the new array instead of the old one
        users = temp;   
    }
    
    // Saving the original pointer to the user array
    struct User** original = users;

    // Traversing through array
    int counter = *count;
    while (counter > 0)
    {
        counter--;
        users++;
    }

    // Creating a defaulted user object
    *users = (struct User*)malloc(sizeof(struct User));
    DefaultUser(*users);

    // Setting inserted name and password
    memcpy((*users)->s_Username, name, MAX_CHAR_NAME);
    memcpy((*users)->s_Password, pass, MAX_CHAR_PASS);

    // Reset the pointer to the user array
    users = original;

    // Adding one user to counter
    *count += 1;
}

void DefaultUser(struct User* user)
{
    char randomCode[MAX_CHAR_CODE];
    for (size_t i = 0; i < MAX_CHAR_CODE - 1; i++)
        randomCode[i] = rand() % 26 + 'A';
    randomCode[MAX_CHAR_CODE - 1] = '\0';
    memcpy(user->s_Code, randomCode, MAX_CHAR_CODE);

#if _DEBUG
#if _PRINT_INFO
    printf(" ~Randomized Code: %s\n", randomCode);
#endif
#endif

    // Default char arrays
    memset(user->s_Password, 'X', MAX_CHAR_PASS);
    memset(user->s_Username, 'X', MAX_CHAR_NAME);
    user->s_Password[MAX_CHAR_PASS - 1] = '\0';
    user->s_Username[MAX_CHAR_NAME - 1] = '\0';

    // Default save data
    user->s_SaveData.s_NumberOfSavedFiles = 0;
    user->s_SaveData.s_Saved = (struct SaveFile**)malloc(sizeof(struct SaveFile*) * MAX_SAVE_FILES);
}

void PrintUserInformation(struct User* user)
{
    printf("\n\n\nPrinting user information\n");
    printf(" Name: \t\t%s\n", user->s_Username);
    printf(" Password: \t%s\n", user->s_Password);
    printf(" Code: \t\t%s\n", user->s_Code);
    printf(" Saved Files: \t%d\n", user->s_SaveData.s_NumberOfSavedFiles);
}

void PrintAllUsers(struct User** users, int* count)
{
    struct User** original = users;
    int counter = *count;
    while (counter > 0)
    {
        PrintUserInformation(*users);
        counter--;
        users++;
    }
    users = original;
}

/*******************
/*  LOCKER
*******************/

void iRunLocker(struct User** user, int* done)
{
    int*            doneKeeper = done;
    char            m_ContentFile[MAX_CHAR_FILE];
    char            m_Content[MAX_CHAR_CONTENT];
    struct User*    m_User = *user;

    // Initialize char arrays
    iResetCurrent(&m_Content, &m_ContentFile);

    // Main loop for the locker
    int logout = 1;
    while (logout == 1 && *doneKeeper == 1)
    {
        char selection = '0';
        iPrintSaveFiles(m_User);
        printf("\n~Active File:\n Name: %s\n", &m_ContentFile);
        printf("\n1. Create new file.\n2. Save active file.\n3. Modify old file.\n4. Print content from file.\n5. Change Password.\n6. Logout.\n7. Quit.\n Input: ");
        fseek(stdin, 0, SEEK_END);
        scanf("%c", &selection);
        system("cls");
        if (!isalpha(selection))
        {
            switch (selection - '0')
            {
            case 1: iLockerWrite(m_User, &m_Content, &m_ContentFile);       break;
            case 2: iSaveAFile(m_User, &m_Content, &m_ContentFile);         break;
            case 3: iModifyFile(m_User, &m_Content, &m_ContentFile);        break;
            case 4: iShowContent(m_User, &m_Content, &m_ContentFile);       break;
            case 5: iChangePassword(m_User);                                break;
            case 6: logout = 0;                                             break;
            case 7: *doneKeeper = 0;                                        break;
            default:                                                        break;
            }
        }
        else printf("Please insert a number, not a letter.\n");
    }

    *user = NULL;
    return;
}

void iLockerWrite(struct User* user, char* content, char* contentFile)
{
    struct SaveData* saveData = &user->s_SaveData;
    struct SaveFile** traveler = saveData->s_Saved;

    // Traversing through array
    int counter = saveData->s_NumberOfSavedFiles;
    while (counter > 0)
    {
        counter--;
        traveler++;
    }

    // Get filename from user
    char name[MAX_CHAR_FILE];
    printf("Create File\n File Name: ");
    scanf("%23s", &name);

    // Saves the path for this file
    (*traveler) = (struct SaveFile*)malloc(sizeof(struct SaveFile));
    memcpy((*traveler)->s_Path, &name, MAX_CHAR_FILE);
    saveData->s_NumberOfSavedFiles++;

    // Creates the actual file
    FILE *ft;
    int ch;
    ft = fopen(name, "w+");
    char buffer[MAX_CHAR_CONTENT];
    memset(buffer, '\0', MAX_CHAR_CONTENT - 1);
    fwrite(buffer, 1, MAX_CHAR_CONTENT, ft);
    fclose(ft);

    // Opens the file to edit
    iEditFile(user, name, content, contentFile);
}

void iSaveAFile(struct User* user, char* content, char* contentFile)
{
    // Check if a file is active first
    if (strcmp(content,     EMPTY_STRING) == 0 ||
        strcmp(contentFile, EMPTY_STRING) == 0)
    {
        printf("No active file.\n");
        return;
    }

    // Write the content down to the file
    FILE *ft;
    int ch;
    ft = fopen(contentFile, "w");
    char buffer[MAX_CHAR_CONTENT];

    // Encrypt the content
    char encrypted[MAX_CHAR_CONTENT];
    memset(encrypted, '\0', MAX_CHAR_CONTENT);
    for (size_t i = 0, iKey = 0; i < strlen(content); i++, iKey++)
    {
        // Resetting the key position
        if (iKey == strlen(user->s_Code)) iKey = 0;

        // Exceptions of encryptions, these characters stay the same
        if (content[i] < 32 || content[i] > 126) encrypted[i] = content[i];

        // Encrypt content character with user-code
        else encrypted[i] = ((content[i] - 32 + user->s_Code[iKey] - 32) % 95) + 32;
    }

    // Write the encrypted char array to the file
    fwrite(encrypted, 1, MAX_CHAR_CONTENT, ft);

    // Close the file
    fclose(ft);

    // Saving the savefile inside the user's information
    struct SaveFile** ptr = user->s_SaveData.s_Saved;
    int counter = user->s_SaveData.s_NumberOfSavedFiles;
    while (counter > 0)
    {
        counter--;
        ptr++;
    }

    // Creates a new save file in the first available position in the array
    *ptr = (struct SaveFile*)malloc(sizeof(struct SaveFile));
    memcpy((*ptr)->s_Path, contentFile, MAX_CHAR_FILE);
    printf("Save completed.\n");
}

void iModifyFile(struct User* user, char* content, char* contentFile)
{
    // Get filename from user
    char name[MAX_CHAR_FILE];
    printf("Edit File\n File Name: ");
    scanf("%23s", &name);

    // Opens the file to edit
    iEditFile(user, name, content, contentFile);
}

void iShowContent(struct User* user, char* content, char* contentFile)
{
    // Get filename from user
    char name[MAX_CHAR_FILE];
    printf("Edit File\n File Name: ");
    scanf("%23s", &name);

    // Simple print of the current file's content
    char tempContent[MAX_CHAR_CONTENT];
    char tempPath[MAX_CHAR_FILE];
    iGetFileContent(user, name, tempContent, tempPath);

    // Print results
    system("cls");
    printf("Content in %s:\n %s\n\n", tempPath, tempContent);
}

void iChangePassword(struct User* user)
{
    char pass_1[MAX_CHAR_FILE];
    char pass_2[MAX_CHAR_FILE];

    // Get password input from user
    printf("Change password\n Password: ");
    scanf("%23s", &pass_1);
    printf("Again please.\n Password: ");
    scanf("%23s", &pass_2);

    // Check if passwords are correct
    if (strcmp(pass_1, pass_2) == 0)
    {
        // Changes the password
        memcpy(user->s_Password, pass_1, MAX_CHAR_PASS);
        printf("Your password have been changed.\n\n");
    }
    else
    {
        // Wrong password
        printf("The two passwords didn't match.\n");
        printf("Your password have not been changed.\n\n");
    }
}

void iEditFile(struct User* user, char* filename, char* content, char* contentFile)
{
    int editDone = 1;

    // Get file content
    iGetFileContent(user, filename, content, contentFile);

    // File not found, reset everything, bad solution, fix this
    if (strcmp(content, INVALID_STRING) == 0)
    {
        system("cls");
        printf("\nFile does not exist\n");
        iResetCurrent(content, contentFile);
        return;
    }

    int pos = strlen(content);

    fseek(stdin, 0, SEEK_END);
    while (editDone == 1)
    {
        // Print current editing screen information
        printf("Editing %s\n****************\n", filename);
        printf("%s", content);

        // Simple single character read to get the typewriter effect, 
        //  it automaticly get's looped because stdin doesn't get flushed
        int nread = -1;
        if (((nread = getc(stdin)) != EOF))
        {
            // Normal Char
            content[pos] = nread;
            content[pos + 1] = '\0';
            pos++;
        }

        // Quiting steps
        if (content[pos - 2] == '-' &&
            content[pos - 1] == '1')
        {
            content[pos - 2] = '\0';
            content[pos - 1] = '\0';
            editDone = 0;
            system("cls");
            printf("Saving file and exiting.\n");
        }
        system("cls");
    }
}

void iGetFileContent(struct User* user, char* filename, char* content, char* contentFile)
{
    char buffer[MAX_CHAR_CONTENT] = EMPTY_STRING;

    // Creates the actual file
    FILE *ft;
    int ch;
    ft = fopen(filename, "r");
    if (ft)
    {
        fread(buffer, 1, MAX_CHAR_CONTENT, ft);
        fclose(ft);

        // Skip this if not filled
        if (strcmp(buffer, "") == 0)
        {
            // Nothing in file, fill variables
            memcpy(content, buffer, MAX_CHAR_CONTENT);
            memcpy(contentFile, filename, MAX_CHAR_FILE);
            return buffer;
        }

        // Decrypt the content
        char decrypted[MAX_CHAR_CONTENT];
        memset(decrypted, '\0', MAX_CHAR_CONTENT);
        for (size_t i = 0, iKey = 0; i < strlen(buffer); i++, iKey++)
        {
            // Resetting the key position
            if (iKey == strlen(user->s_Code)) iKey = 0;

            // Exceptions, characters that have not been encrypted
            if (buffer[i] < 32 || buffer[i] > 126) decrypted[i] = buffer[i];

            // Special case, modulus can't handle correcly
            else if (((int)(buffer[i] + 32)) - ((int)(user->s_Code[iKey] + 32)) >= 0) decrypted[i] = ((int)(buffer[i] + 32)) - ((int)(user->s_Code[iKey] + 32)) + 32;

            // Normal decryption
            else decrypted[i] = ((int)(((int)(buffer[i] + 32))) - ((int)(user->s_Code[iKey] + 32)) % 95) + 32;
        }

        // Copy the decrypted data to the buffer to use as return ptr 
        memcpy(buffer, decrypted, MAX_CHAR_CONTENT);

        // Replace the currently active content with the new loaded
        memcpy(content, buffer, MAX_CHAR_CONTENT);
        memcpy(contentFile, filename, MAX_CHAR_FILE);
    }
    else
    {
        // No file was found, put error string
        memcpy(content, INVALID_STRING, MAX_CHAR_CONTENT);
        memcpy(contentFile, INVALID_STRING, MAX_CHAR_FILE);
    }
}

void iResetCurrent(char* content, char* contentFile)
{
    memset(content,     '\0', MAX_CHAR_CONTENT);
    memset(contentFile, '\0', MAX_CHAR_FILE);
    memcpy(content,     EMPTY_STRING, EMPTY_STRING_SIZE);
    memcpy(contentFile, EMPTY_STRING, EMPTY_STRING_SIZE);
}

void iPrintSaveFiles(struct User* user)
{
    printf("~Your Savefiles: \n");
    struct SaveFile** ptr = user->s_SaveData.s_Saved;
    int counter = user->s_SaveData.s_NumberOfSavedFiles;
    if (counter == 0) printf(" No saved files.\n");
    while (counter > 0)
    {
        iPrintSaveFile(*ptr);
        counter--;
        ptr++;
    }
}

void iPrintSaveFile(struct SaveFile* sf)
{
    printf(" Path: %s\n", sf->s_Path);
}
